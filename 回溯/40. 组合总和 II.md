# 40. 组合总和 II

## 题目描述

给定一个数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。

candidates 中的每个数字在每个组合中只能使用一次。

**说明：**

- 所有数字（包括目标数）都是正整数。

- 解集不能包含重复的组合。

## 示例

**示例 1：**

``` text

输入: candidates = [10,1,2,7,6,1,5], target = 8,

所求解集为:
[
[1, 7],
[1, 2, 5],
[2, 6],
[1, 1, 6]
]
```

**示例 2：**

``` text

输入: candidates = [2,5,2,1,2], target = 5,

所求解集为:
[
[1,2,2],
[5]
]
```

## 代码

``` ts

function combinationSum2(candidates: number[], target: number): number[][] {
    const res = []
    const path = []
    const len = candidates.length
    candidates.sort((a, b) => a - b)
    function dfs(sum: number, startIndex: number) {
        if (sum > target) return
        if (sum === target) {
            res.push([...path])
            return
        }

        for (let i = startIndex; i < len; i++) {
            if (i > startIndex && candidates[i] === candidates[i - 1]) continue
            // i > startIndex 说明当前的数是在当前层的，并且第一次出现的数，的后续回溯，的包涵后面相同的数的，所以 candidates[i] === candidates[i - 1] 的时候直接跳过 如果是 i > 0 说明当前的数是在下一层的，这样就会漏掉一些情况
            path.push(candidates[i])
            dfs(sum + candidates[i], i + 1) // i + 1 是因为不可以重复读取当前的数
            path.pop()
        }
    }
    dfs(0, 0)
    return res
}

```
